# test
library("mvtnorm")
library("rootSolve")
library("CMetafoR")

generate_simulated_data <- function(n = 2000) {
  prevmi <- rbinom(n, size = 1, prob = 0.50)
  age <- runif(n)
  angina <- rbinom(n, size = 1, prob = 0.50)
  ejecfr <- runif(n)
  lvscor <- runif(n)
  prxlad31 <- runif(n)
  prxves31 <- runif(n)

  treatment <- rbinom(n, 1, 0.5)

  source1 <- 1
  source2 <- prevmi + age + angina + ejecfr
  source3 <- -1 + 0.5*(prevmi + age + angina + ejecfr)
  vProb <- exp(cbind(source1, source2, source3))
  mChoices <- apply(vProb, 1, rmultinom, n = 1, size = 1)

  outcome <- rbinom(n, 1, plogis(-1 + 0.5*(prevmi + age + angina + ejecfr) * treatment))

  return(data.frame(prevmi,
                    age,
                    angina,
                    ejecfr,
                    lvscor,
                    prxlad31,
                    prxves31,
                    treatment,
                    source1 = mChoices[1,],
                    source2 = mChoices[2,],
                    source3 = mChoices[3,],
                    outcome))
}

###########------- Parameters specification
p=10
beta_coefs=matrix(rep(log(1.05),p),byrow=F,nrow=1)      # coef of R model
xi_coefs=matrix(rep(log(1.2),p),byrow=F,nrow=1)      # coef of S model
zeta_coefs=matrix(rep(log(1.1),p),byrow=F,nrow=1)    # coef of S model
alpha_1=matrix(rep(log(0.8),p+1),byrow=F,nrow=1)     # coef of A model
alpha_2=log(1.1)                                     # coef of A model
alpha_3=matrix(rep(log(1.1),p),byrow=F,nrow=1)       # coef of A model
theta_0=c(1,2,rep(0.75,p-1))                        # coef of Y0 model
theta_1=c(10,8,rep(1.5,p-1))                        # coef of Y1 model
###########------- Data generation (for the use of both internal and external case)
Gen=function(n,n_m){
  ### Function to be solved - this function will be called to solve for intercepts in each data generation model
  tosolve <- function(ints, fxname, goalmarg){
    values <- fxname(ints)                          # simulated individual expected values at given intercept value
    if(is.null(dim(values))){                       # obtain mean of simulated individual expected values
      empmeans <-  mean(values)}else{
        empmeans <-  colMeans(values)
      }
    diff = empmeans - goalmarg                      # difference from empirical mean to goal marginal distribution
    return(diff)
  }
  ## X
  X1_latent=rnorm(n,0,1)
  X1_sort=split(sort(X1_latent), sort(rep_len(1:9, length(X1_latent))))
  X1=as.factor(ifelse(X1_latent%in%X1_sort$`1` ,1,ifelse(X1_latent%in%c(X1_sort$`2`,X1_sort$`3`),2, ifelse(X1_latent%in%c(X1_sort$`4`,X1_sort$`5`,X1_sort$`6`),3, ifelse(X1_latent%in%c(X1_sort$`7`,X1_sort$`8`),4, 5)))))
  X1_1=ifelse(X1==1,1,0);X1_2=ifelse(X1==2,1,0);X1_3=ifelse(X1==3,1,0);X1_4=ifelse(X1==4,1,0);X1_5=ifelse(X1==5,1,0)
  sigma=matrix(rep(0.25,(p-1)*(p-1)),nrow=(p-1))
  diag(sigma)=1
  X2_10=rmvnorm(n, rep(0.1,p-1), sigma)
  X=matrix(cbind(X1, X2_10),byrow=F,ncol=p)
  ## R
  gen_pr_r <- function(beta0){
    prob_r <- plogis(as.numeric(beta0 + beta_coefs%*%t(X)) )  # probability generated by model at given intercept value
    return(prob_r)
  }
  goalmarg_r <- n_m/n
  rootr <- multiroot(f=tosolve, start=c(-1), fxname=gen_pr_r, goalmarg=goalmarg_r, atol=1e-12)$root # find root for R model
  R=rbinom(n, size=1, p=gen_pr_r(rootr))                     # simulate R using intercept solution
  ## S
  gen_pr_s <- function(xi_zeta0){
    odds <- matrix(nrow=length(R[R==1]), ncol=2)             # create empty matrix to store odds
    odds[,1] <- exp(xi_zeta0[1] + xi_coefs%*%t(X[R==1,]))    # odds(1vs0) at given intercept value
    odds[,2] <- exp(xi_zeta0[2] + zeta_coefs%*%t(X[R==1,]))  # odds(2vs0) at given intercept value
    denom <- as.matrix(1 + rowSums(odds))                    # sum of 3 odds to be used as denominator of pr
    prob_s <- cbind(1/denom, odds[,1]/denom)
    return(prob_s)
  }
  goalmarg_s <- c(4/(4+2+1), 2/(4+2+1))
  roots <- multiroot(f=tosolve, start=c(-3,-2), fxname=gen_pr_s, goalmarg=goalmarg_s, atol=1e-12)$root # find root for mediator model
  prS <- cbind(gen_pr_s(roots), 1 - rowSums(gen_pr_s(roots))) # obtain probabilities for each S level using intercept solutions
  S_R <- Hmisc::rMultinom(prS,1)
  S=rep(NA,length(R))
  S[R==1]=S_R
  ## A
  A_R=rbinom(length(S_R),1,p=plogis(as.numeric(alpha_1%*%t(data.frame(cbind(rep(1,length(S_R)),X[which(R==1),])))+t(alpha_2*S_R)+alpha_3%*%t(sweep(X[which(R==1),],1,S_R,`*`)))))
  A=rep(NA,length(R))
  A[R==1]=A_R
  # A1=rbinom(length(S_R[S_R==1]), size=1, p=plogis(as.numeric(alpha_1%*%t(data.frame(cbind(rep(1,length(S_R[S_R==1])),X[which(S_R==1),]))))))
  # A2=rbinom(length(S_R[S_R==2]), size=1, p=plogis(as.numeric(alpha_2%*%t(data.frame(cbind(rep(1,length(S_R[S_R==2])),X[which(S_R==2),]))))))
  # A3=rbinom(length(S_R[S_R==3]), size=1, p=plogis(as.numeric(alpha_3%*%t(data.frame(cbind(rep(1,length(S_R[S_R==3])),X[which(S_R==3),]))))))
  # A_R=rep(NA,length(S_R));A_R[S_R==1]=A1;A_R[S_R==2]=A2;A_R[S_R==3]=A3
  # A=rep(NA,length(R));A[R==1]=A_R
  ## Y
  f1=function(x) sin(x)
  f2=function(x) exp(-0.25*x)
  f3=function(x) 0.02*x^2+(2*(1+0.1*x))^2+2*(0.015*x)^3
  # Y=1+5*A+
  #   1*X[,1]+f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
  #   1.35*A*X1_2+1.4*A*X1_3+1.45*A*X1_4+1.5*A*X1_5+
  #   0.8*A*X[,2]+0.7*A*X[,3]+0.6*A*X[,4]+0.5*A*X[,5]+
  #   rnorm(n)
  Y1=1+5+X[,1]+
    f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
    1.8*X1_1+0.35*X1_2+2.4*X1_3+1.45*X1_4+0.5*X1_5+
    0.8*X[,2]+0.7*X[,3]+0.6*X[,4]+0.5*X[,5]+
    rnorm(n)
  Y0=1+X[,1]+
    f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
    rnorm(n)
  Y=Y0*(1-A)+Y1*A
  #Y0=theta_0[1]+theta_0[2]*X[,1]+f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+rnorm(n)
  #Y1=theta_1[1]+theta_1[2]*X[,1]+f1(theta_1[3]*X[,2])+f1(theta_1[4]*X[,3])+f1(theta_1[5]*X[,4])+f2(theta_1[6]*X[,5])+f2(theta_1[7]*X[,6])+f2(theta_1[8]*X[,7])+f3(theta_1[9]*X[,8])+f3(theta_1[10]*X[,9])+f3(theta_1[11]*X[,10])+rnorm(n)
  #Y=Y0*(1-A)+Y1*A

  return(data.frame(X,R,S,A,Y,Y1,Y0))
}

###########------- Sample size specification
n=10000
#n=100000
n_m=1000
# n_m=2000
# n_m=5000

Data=Gen(n, n_m)
hist(Data$Y[which(Data$A==0)]);mean(Data$Y[which(Data$A==0)])
hist(Data$Y[which(Data$A==1)]);mean(Data$Y[which(Data$A==1)])
hist(Data$Y[which(Data$R==1)]);mean(Data$Y[which(Data$R==1)])

dd <- subset(Data, R == 1)






X_ext <- Data[Data$R == 0, 2:10]
X <- Data[Data$R == 1, 2:10]
Y <- Data$Y[Data$R == 1]
A <- Data$A[Data$R == 1]
S <- Data$S[Data$R == 1]
S <- letters[S]
EM <- Data$X1[Data$R == 1]
EM <- LETTERS[EM]
# EM <- factor(EM, levels = c("E", "D", "C", "B", "A"))
EM_ext <- Data$X1[Data$R == 0]
EM_ext <- LETTERS[EM_ext]

table(A)
summary(Y)
table(S)
table(EM)
table(EM_ext)
dim(X)
dim(X_ext)


### STE_nested test
# regular
si <- STE_nested(
  X = X, Y = Y, EM = EM, S = S, A = A,
  cross_fitting = FALSE,
  source_model = "nnet.multinom",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
print(si)
summary(si)
plot(si, use_scb = TRUE)
plot(si, use_scb = FALSE)

# cross-fitting
sicf <- STE_nested(
  X = X, Y = Y, EM = EM, S = S, A = A,
  cross_fitting = TRUE,
  replications = 5,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "joint",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
print(sicf)
summary(sicf)
plot(sicf, use_scb = TRUE)
plot(sicf, use_scb = FALSE)


### ATE_nested test
# regular
ai <- ATE_nested(
  X = X, Y = Y, S = S, A = A,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
summary(ai)
print(ai)
plot(ai)

aicf <- ATE_nested(
  X = X, Y = Y, S = S, A = A,
  cross_fitting = TRUE,
  replications = 50,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "joint",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
summary(aicf)
print(aicf)
plot(aicf)



### STE_external test
se <- STE_external(
  X = X, Y = Y, EM = EM, S = S, A = A, X_external = X_ext, EM_external = EM_ext,
  cross_fitting = FALSE,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  external_model = "SuperLearner",
  external_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
print(se)
summary(se)

secf <- STE_external(
  X = X, Y = Y, EM = EM, S = S, A = A, X_external = X_ext, EM_external = EM_ext,
  cross_fitting = FALSE,
  replications = 10,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "joint",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  external_model = "SuperLearner",
  external_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
print(secf)
summary(secf)

### ATE_external test
ae <- ATE_external(
  X = X, Y = Y, S = S, A = A, X_external = X_external,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  external_model = "SuperLearner",
  external_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
summary(ae)
print(ae)

aecf <- ATE_external(
  X = X, Y = Y, S = S, A = A, X_external = X_external,
  cross_fitting = TRUE,
  replications = 5L,
  source_model = "glmnet.multinom",
  source_model_args = list(),
  treatment_model_type = "joint",
  treatment_model = "SuperLearner",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  external_model = "SuperLearner",
  external_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model = "SuperLearner",
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
summary(aecf)
print(aecf)
