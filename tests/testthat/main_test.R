## code to prepare `dat_nested` dataset goes here

library("mvtnorm")
library("rootSolve")

set.seed(20231218)

generate_simulated_data <- function(n = 2000) {
  prevmi <- rbinom(n, size = 1, prob = 0.50)
  age <- runif(n)
  angina <- rbinom(n, size = 1, prob = 0.50)
  ejecfr <- runif(n)
  lvscor <- runif(n)
  prxlad31 <- runif(n)
  prxves31 <- runif(n)

  treatment <- rbinom(n, 1, 0.5)

  source1 <- 1
  source2 <- prevmi + age + angina + ejecfr
  source3 <- -1 + 0.5*(prevmi + age + angina + ejecfr)
  vProb <- exp(cbind(source1, source2, source3))
  mChoices <- apply(vProb, 1, rmultinom, n = 1, size = 1)

  outcome <- rbinom(n, 1, plogis(-1 + 0.5*(prevmi + age + angina + ejecfr) * treatment))

  return(data.frame(prevmi,
                    age,
                    angina,
                    ejecfr,
                    lvscor,
                    prxlad31,
                    prxves31,
                    treatment,
                    source1 = mChoices[1,],
                    source2 = mChoices[2,],
                    source3 = mChoices[3,],
                    outcome))
}

###########------- Parameters specification
p=10
beta_coefs=matrix(rep(log(1.05),p),byrow=F,nrow=1)      # coef of R model
xi_coefs=matrix(rep(log(1.2),p),byrow=F,nrow=1)      # coef of S model
zeta_coefs=matrix(rep(log(1.1),p),byrow=F,nrow=1)    # coef of S model
alpha_1=matrix(rep(log(0.8),p+1),byrow=F,nrow=1)     # coef of A model
alpha_2=log(1.1)                                     # coef of A model
alpha_3=matrix(rep(log(1.1),p),byrow=F,nrow=1)       # coef of A model
theta_0=c(1,2,rep(0.75,p-1))                        # coef of Y0 model
theta_1=c(10,8,rep(1.5,p-1))                        # coef of Y1 model
###########------- Data generation (for the use of both internal and external case)
Gen=function(n,n_m){
  ### Function to be solved - this function will be called to solve for intercepts in each data generation model
  tosolve <- function(ints, fxname, goalmarg){
    values <- fxname(ints)                          # simulated individual expected values at given intercept value
    if(is.null(dim(values))){                       # obtain mean of simulated individual expected values
      empmeans <-  mean(values)}else{
        empmeans <-  colMeans(values)
      }
    diff = empmeans - goalmarg                      # difference from empirical mean to goal marginal distribution
    return(diff)
  }
  ## X
  X1_latent=rnorm(n,0,1)
  X1_sort=split(sort(X1_latent), sort(rep_len(1:9, length(X1_latent))))
  X1=as.factor(ifelse(X1_latent%in%X1_sort$`1` ,1,ifelse(X1_latent%in%c(X1_sort$`2`,X1_sort$`3`),2, ifelse(X1_latent%in%c(X1_sort$`4`,X1_sort$`5`,X1_sort$`6`),3, ifelse(X1_latent%in%c(X1_sort$`7`,X1_sort$`8`),4, 5)))))
  X1_1=ifelse(X1==1,1,0);X1_2=ifelse(X1==2,1,0);X1_3=ifelse(X1==3,1,0);X1_4=ifelse(X1==4,1,0);X1_5=ifelse(X1==5,1,0)
  sigma=matrix(rep(0.25,(p-1)*(p-1)),nrow=(p-1))
  diag(sigma)=1
  X2_10=rmvnorm(n, rep(0.1,p-1), sigma)
  X=matrix(cbind(X1, X2_10),byrow=F,ncol=p)
  ## R
  gen_pr_r <- function(beta0){
    prob_r <- plogis(as.numeric(beta0 + beta_coefs%*%t(X)) )  # probability generated by model at given intercept value
    return(prob_r)
  }
  goalmarg_r <- n_m/n
  rootr <- multiroot(f=tosolve, start=c(-1), fxname=gen_pr_r, goalmarg=goalmarg_r, atol=1e-12)$root # find root for R model
  R=rbinom(n, size=1, p=gen_pr_r(rootr))                     # simulate R using intercept solution
  ## S
  gen_pr_s <- function(xi_zeta0){
    odds <- matrix(nrow=length(R[R==1]), ncol=2)             # create empty matrix to store odds
    odds[,1] <- exp(xi_zeta0[1] + xi_coefs%*%t(X[R==1,]))    # odds(1vs0) at given intercept value
    odds[,2] <- exp(xi_zeta0[2] + zeta_coefs%*%t(X[R==1,]))  # odds(2vs0) at given intercept value
    denom <- as.matrix(1 + rowSums(odds))                    # sum of 3 odds to be used as denominator of pr
    prob_s <- cbind(1/denom, odds[,1]/denom)
    return(prob_s)
  }
  goalmarg_s <- c(4/(4+2+1), 2/(4+2+1))
  roots <- multiroot(f=tosolve, start=c(-3,-2), fxname=gen_pr_s, goalmarg=goalmarg_s, atol=1e-12)$root # find root for mediator model
  prS <- cbind(gen_pr_s(roots), 1 - rowSums(gen_pr_s(roots))) # obtain probabilities for each S level using intercept solutions
  S_R <- Hmisc::rMultinom(prS,1)
  S=rep(NA,length(R))
  S[R==1]=S_R
  ## A
  A_R=rbinom(length(S_R),1,p=plogis(as.numeric(alpha_1%*%t(data.frame(cbind(rep(1,length(S_R)),X[which(R==1),])))+t(alpha_2*S_R)+alpha_3%*%t(sweep(X[which(R==1),],1,S_R,`*`)))))
  A=rep(NA,length(R))
  A[R==1]=A_R

  ## Y
  f1=function(x) sin(x)
  f2=function(x) exp(-0.25*x)
  f3=function(x) 0.02*x^2+(2*(1+0.1*x))^2+2*(0.015*x)^3

  Y1=1+5+X[,1]+
    f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
    1.8*X1_1+0.35*X1_2+2.4*X1_3+1.45*X1_4+0.5*X1_5+
    0.8*X[,2]+0.7*X[,3]+0.6*X[,4]+0.5*X[,5]+
    rnorm(n)
  Y0=1+X[,1]+
    f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
    rnorm(n)
  Y=Y0*(1-A)+Y1*A

  return(data.frame(X,R,S,A,Y,Y1,Y0))
}

###########------- Sample size specification
n=10000
n_m=1000

Data=Gen(n, n_m)
names(Data)[1] <- "EM"
Data$EM <- letters[Data$EM]

dat_nested <- subset(Data, R == 1)
dat_external <- subset(Data, R == 0)

dat_nested$S <- LETTERS[dat_nested$S]

### STE_nested test
# regular
sn <- STE_nested(
  X = dat_nested[, 2:9],
  Y = dat_nested$Y,
  EM = dat_nested$EM,
  S = dat_nested$S,
  A = dat_nested$A,
  cross_fitting = FALSE,
  source_model = "MN.nnet",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
print(sn)
summary(sn)
plot(sn, use_scb = TRUE)
plot(sn, use_scb = FALSE)

# # cross-fitting
# sncf <- STE_nested(
#   X = dat_nested[, 2:9],
#   Y = dat_nested$Y,
#   EM = dat_nested$EM,
#   S = dat_nested$S,
#   A = dat_nested$A,
#   cross_fitting = TRUE,
#   replications = 5,
#   source_model = "MN.glmnet",
#   source_model_args = list(),
#   treatment_model_type = "joint",
#   treatment_model_args = list(
#     family = binomial(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   ),
#   outcome_model_args = list(
#     family = gaussian(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   )
# )
# print(sncf)
# summary(sncf)
# plot(sncf, use_scb = TRUE)
# plot(sncf, use_scb = FALSE)


### ATE_nested test
# regular
an <- ATE_nested(
  X = dat_nested[, 2:9],
  Y = dat_nested$Y,
  S = dat_nested$S,
  A = dat_nested$A,
  source_model = "MN.glmnet",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
summary(an)
print(an)
plot(an)

# ancf <- ATE_nested(
#   X = dat_nested[, 2:9],
#   Y = dat_nested$Y,
#   S = dat_nested$S,
#   A = dat_nested$A,
#   cross_fitting = TRUE,
#   replications = 10L,
#   source_model = "MN.glmnet",
#   source_model_args = list(),
#   treatment_model_type = "joint",
#   treatment_model_args = list(
#     family = binomial(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   ),
#   outcome_model_args = list(
#     family = gaussian(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   )
# )
# summary(ancf)
# print(ancf)
# plot(ancf)



### STE_external test
se <- STE_external(
  X = dat_nested[, 2:9],
  Y = dat_nested$Y,
  EM = dat_nested$EM,
  S = dat_nested$S,
  A = dat_nested$A,
  X_external = dat_external[, 2:9],
  EM_external = dat_external$EM,
  cross_fitting = FALSE,
  source_model = "MN.glmnet",
  source_model_args = list(trace = FALSE),
  treatment_model_type = "separate",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  external_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
print(se)
summary(se)

# secf <- STE_external(
#   X = dat_nested[, 2:9],
#   Y = dat_nested$Y,
#   EM = dat_nested$EM,
#   S = dat_nested$S,
#   A = dat_nested$A,
#   X_external = dat_external[, 2:9],
#   EM_external = dat_external$EM,
#   cross_fitting = FALSE,
#   replications = 10,
#   source_model = "MN.glmnet",
#   source_model_args = list(),
#   treatment_model_type = "joint",
#   treatment_model_args = list(
#     family = binomial(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   ),
#   external_model_args = list(
#     family = binomial(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   ),
#   outcome_model_args = list(
#     family = gaussian(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   )
# )
# print(secf)
# summary(secf)

### ATE_external test
ae <- ATE_external(
  X = dat_nested[, 2:9],
  Y = dat_nested$Y,
  S = dat_nested$S,
  A = dat_nested$A,
  X_external = dat_external[, 2:9],
  source_model = "MN.glmnet",
  source_model_args = list(),
  treatment_model_type = "separate",
  treatment_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  external_model_args = list(
    family = binomial(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  ),
  outcome_model_args = list(
    family = gaussian(),
    SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
    cvControl = list(V = 5L)
  )
)
summary(ae)
print(ae)

# aecf <- ATE_external(
#   X = X, Y = Y, S = S, A = A, X_external = X_ext,
#   cross_fitting = TRUE,
#   replications = 5L,
#   source_model = "MN.glmnet",
#   source_model_args = list(),
#   treatment_model_type = "joint",
#   treatment_model_args = list(
#     family = binomial(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   ),
#   external_model_args = list(
#     family = binomial(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   ),
#   outcome_model_args = list(
#     family = gaussian(),
#     SL.library = c("SL.glmnet", "SL.nnet", "SL.glm"),
#     cvControl = list(V = 5L)
#   )
# )
# summary(aecf)
# print(aecf)
